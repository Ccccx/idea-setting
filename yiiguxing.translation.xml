<application>
  <component name="AppStorage">
    <histories>
      <item value="Composite Health Indicator Configuration" />
      <item value="donate" />
      <item value="* Apply this {@code BeanPostProcessor} to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean * instance and the objects created by the FactoryBean (as of Spring 2.0). The * post-processor can decide whether to apply to either the FactoryBean or created * objects or both through corresponding {@code bean instanceof FactoryBean} checks. * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method, * in contrast to all other {@code BeanPostProcessor} callbacks. * &lt;p&gt;The default implementation returns the given {@code bean} as-is." />
      <item value="* Apply this {@code BeanPostProcessor} to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * &lt;p&gt;The default implementation returns the given {@code bean} as-is." />
      <item value="Instantiation Aware Bean Post Processor" />
      <item value="* &lt;p&gt;Typically, post-processors that populate beans via marker interfaces * or the like will implement {@link #postProcessBeforeInitialization}, * while post-processors that wrap beans with proxies will normally * implement {@link #postProcessAfterInitialization}." />
      <item value="* Factory hook that allows for custom modification of new bean instances &amp;mdash; * for example, checking for marker interfaces or wrapping beans with proxies." />
      <item value="* Fully create a new bean instance of the given class with the specified * autowire strategy. All constants defined in this interface are supported here. * &lt;p&gt;Performs full initialization of the bean, including all applicable * {@link BeanPostProcessor BeanPostProcessors}. This is effectively a superset * of what {@link #autowire} provides, adding {@link #initializeBean} behavior." />
      <item value="deserialized" />
      <item value="Bean Post Processors" />
      <item value="Fully create a new bean instance of the given class. * &lt;p&gt;Performs full initialization of the bean, including all applicable" />
      <item value="* Initialize the given raw bean, applying factory callbacks * such as {@code setBeanName} and {@code setBeanFactory}, * also applying all bean post processors (including ones which * might wrap the given raw bean)." />
      <item value="etc" />
      <item value="Constant that indicates no externally defined autowiring. Note that * BeanFactoryAware etc and annotation-driven injection will still be applied." />
      <item value="* Check if this bean factory contains a bean definition with the given name. * &lt;p&gt;Does not consider any hierarchy this factory may participate in, * and ignores any singleton beans that have been registered by * other means than bean definitions. * @param beanName the name of the bean to look for * @return if this bean factory contains a bean definition with the given name * @see #containsBean" />
      <item value="Return a provider for the specified bean, allowing for lazy on-demand retrieval * of instances, including availability and uniqueness options." />
      <item value="arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one)" />
      <item value="* Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject} * will return the factory, not the instance returned by the factory." />
      <item value="FACTORY BEAN PREFIX" />
      <item value="Which type of instance will be returned * depends on the bean factory configuration" />
      <item value="or a single shared instance (a superior * alternative to the Singleton design pattern, in which the instance is a * singleton in the scope of the factory)" />
      <item value="the factory will return either an independent instance of a contained object * (the Prototype design pattern)," />
      <item value="independent" />
      <item value="either" />
      <item value="This interface is implemented by objects that hold a number of bean definitions" />
      <item value="further interfaces such as {@link ListableBeanFactory} and * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory} * are available for specific purposes." />
      <item value="This is the basic client view of a bean container;" />
      <item value="The root interface for accessing a Spring bean container." />
      <item value="* This is the basic client view of a bean container;" />
      <item value="further scopes are available depending on the concrete application * context" />
      <item value="the API is the same" />
      <item value="n which the instance is a * singleton in the scope of the factory" />
      <item value="Which" />
      <item value="a superior * alternative to the Singleton design pattern" />
      <item value="alternative" />
      <item value="superior" />
      <item value="Prototype" />
      <item value="a single shared instance" />
      <item value="he Prototype design pattern" />
      <item value="of" />
      <item value="contained" />
      <item value="the factory will return either an independent instance of a contained object" />
      <item value="* the factory will return either an independent instance of a contained object" />
      <item value="Depending on the bean definition," />
      <item value="each uniquely identified by a String name" />
      <item value="identified" />
      <item value="uniquely" />
      <item value="This interface is implemented by objects that hold a number of bean definitions," />
      <item value="are available for specific purposes." />
      <item value="purposes" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1338" />
        <entry key="ENGLISH" value="1465" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="19" />
        <entry key="FILIPINO" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6ad5b78ae4e20181" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>